<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ExSeq Brain AD - Spatial Genomics Data Visualization</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #f5f5f5;
      color: #333;
      padding: 20px;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    h1 {
      margin-bottom: 20px;
      color: #2c3e50;
    }

    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      padding: 15px;
      background: #f9f9f9;
      border-radius: 6px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .control-group label {
      font-size: 12px;
      font-weight: 600;
      color: #666;
    }

    .control-group select,
    .control-group input[type="text"],
    .control-group input[type="range"] {
      padding: 6px 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }

    .control-group input[type="file"] {
      font-size: 14px;
      cursor: pointer;
    }

    .control-group input[type="range"] {
      width: 150px;
    }

    .control-group select {
      min-width: 200px;
    }

    .stats {
      display: flex;
      gap: 20px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .stat-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px 20px;
      border-radius: 6px;
      min-width: 150px;
    }

    .stat-card h3 {
      font-size: 12px;
      opacity: 0.9;
      margin-bottom: 5px;
    }

    .stat-card p {
      font-size: 24px;
      font-weight: bold;
    }

    .stat-card.secondary {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }

    .stat-card.success {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    }

    .stat-card.warning {
      background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
    }

    #scatterplot {
      width: 100%;
      border: 1px solid #ddd;
      border-radius: 6px;
      background: white;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    .status {
      text-align: left;
      padding: 15px;
      background: #e8f5e9;
      color: #2e7d32;
      border-radius: 4px;
      margin-bottom: 15px;
      font-size: 14px;
      line-height: 1.6;
    }

    .status.error {
      background: #ffebee;
      color: #c62828;
    }

    .status.loading {
      background: #e3f2fd;
      color: #1976d2;
    }

    .status code {
      background: rgba(0, 0, 0, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }

    .status.error code {
      background: rgba(255, 255, 255, 0.3);
    }

    /* Tooltip styling */
    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 10px;
      border-radius: 4px;
      pointer-events: none;
      font-size: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      z-index: 1000;
    }

    .axis-label {
      font-size: 12px;
      fill: #666;
    }

    #legend {
      font-size: 12px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
      padding: 4px;
      cursor: pointer;
      border-radius: 4px;
      transition: background-color 0.2s;
    }

    .legend-item:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 3px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      flex-shrink: 0;
    }

    .legend-item.hidden .legend-color {
      opacity: 0.3;
    }

    .legend-item.hidden .legend-label {
      text-decoration: line-through;
      opacity: 0.5;
    }

    .legend-label {
      flex: 1;
      user-select: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ExSeq Brain AD - Spatial Genomics Data Visualization</h1>
    
    <div class="status" id="status">Initializing...</div>

    <div class="stats" id="stats" style="display: none;">
      <div class="stat-card">
        <h3>Total Records</h3>
        <p id="totalRecords">-</p>
      </div>
      <div class="stat-card secondary">
        <h3>Unique Genes</h3>
        <p id="uniqueGenes">-</p>
      </div>
      <div class="stat-card success">
        <h3>Unique Regions</h3>
        <p id="uniqueRegions">-</p>
      </div>
      <div class="stat-card warning">
        <h3>Visible Points</h3>
        <p id="visiblePoints">-</p>
      </div>
    </div>

    <div class="controls" id="controls">
      <div class="control-group" id="sampleSelectorGroup">
        <label>Sample</label>
        <select id="sampleSelector" onchange="loadSampleFromPath(this.value)">
          <option value="">Select a sample...</option>
        </select>
      </div>
      <div class="control-group" id="fileInputGroup" style="display: none;">
        <label>Load Data</label>
        <input type="file" id="fileInput" accept=".csv" onchange="handleFileSelect(event)" style="padding: 6px 0; cursor: pointer;">
      </div>
      <div class="control-group">
        <label>Region</label>
        <select id="regionFilter" onchange="updateVisualization()">
          <option value="">All Regions</option>
        </select>
      </div>
      <div class="control-group">
        <label>Gene</label>
        <select id="geneFilter" onchange="updateVisualization()">
          <option value="">All Genes</option>
        </select>
      </div>
      <div class="control-group" id="cellTypeFilterGroup" style="display: none;">
        <label>Cell Type</label>
        <select id="cellTypeFilter" onchange="updateVisualization()">
          <option value="">All Cell Types</option>
        </select>
      </div>
      <div class="control-group">
        <label>Z-Slice Range</label>
        <input type="range" id="zRange" min="0" max="10" step="0.1" value="10" 
               oninput="document.getElementById('zRangeValue').textContent = this.value; updateVisualization();">
        <span style="font-size: 12px;">Max: <span id="zRangeValue">10</span></span>
      </div>
      <div class="control-group">
        <label>Opacity</label>
        <input type="range" id="opacityRange" min="0.1" max="1" step="0.1" value="0.5"
               oninput="document.getElementById('opacityValue').textContent = this.value; updateVisualization();">
        <span style="font-size: 12px;">Value: <span id="opacityValue">0.5</span></span>
      </div>
      <div class="control-group">
        <label>Point Size</label>
        <input type="range" id="pointSize" min="1" max="10" step="0.5" value="2"
               oninput="document.getElementById('pointSizeValue').textContent = this.value; updateVisualization();">
        <span style="font-size: 12px;">Size: <span id="pointSizeValue">2</span></span>
      </div>
    </div>

    <div style="display: flex; gap: 20px; align-items: flex-start;">
      <div style="flex: 1; min-width: 0; position: relative;">
        <canvas id="scatterplot" style="display: block; border: 1px solid #ddd; border-radius: 4px;"></canvas>
        <svg id="axes" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 1;"></svg>
      </div>
      <div id="legend" style="min-width: 200px; max-width: 250px; max-height: 600px; overflow-y: auto; padding: 15px; background: #f9f9f9; border-radius: 6px; border: 1px solid #ddd; display: none;">
        <h3 style="margin: 0 0 15px 0; font-size: 14px; font-weight: 600; color: #333;">Gene Colors</h3>
        <div id="legendItems"></div>
      </div>
    </div>
    <div class="loading" id="loading" style="display: none;">Loading data...</div>
  </div>

  <div class="tooltip" id="tooltip" style="display: none;"></div>

  <script>
    // Sample configuration - list of all available samples
    const samples = [
      {
        path: 'data/csvs/fem2_5x_F5_B_left_regions_genes_with_cell_types.csv',
        name: 'fem2_5x_F5_B_left'
      },
      {
        path: 'data/csvs/fem2_5x_F5_B_right_regions_genes_with_cell_types.csv',
        name: 'fem2_5x_F5_B_right'
      },
      {
        path: 'data/csvs/fem2_WT_F3_B_left_regions_genes_with_cell_types.csv',
        name: 'fem2_WT_F3_B_left'
      },
      {
        path: 'data/csvs/fem3_5x_E7_A_left_regions_genes_with_cell_types.csv',
        name: 'fem3_5x_E7_A_left'
      },
      {
        path: 'data/csvs/fem3_WTE1_B_L_regions_genes_with_cell_types.csv',
        name: 'fem3_WTE1_B_L'
      },
      {
        path: 'data/csvs/fem3_WTE1_B_R_regions_genes_with_cell_types.csv',
        name: 'fem3_WTE1_B_R'
      },
      {
        path: 'data/csvs/fem4_5x_F8_A_R_regions_genes_with_cell_types.csv',
        name: 'fem4_5x_F8_A_R'
      },
      {
        path: 'data/csvs/fem4_WT_F11_regions_genes_with_cell_types.csv',
        name: 'fem4_WT_F11'
      }
    ];

    let rawData = [];
    let filteredData = [];
    let canvas, ctx, axesSvg, xScale, yScale;
    let hasCellType = false;
    let colorScale = null;
    const margin = { top: 40, right: 40, bottom: 60, left: 60 };
    let currentFileName = null;
    const MAX_POINTS_TO_RENDER = 100000; // Maximum points to render for performance
    let renderTimeout = null;
    let hoveredPoint = null;

    // Column name normalization function
    function normalizeColumns(data) {
      // Reset cell type flag before checking
      hasCellType = false;
      
      const normalized = data.map(row => {
        const norm = {};
        // Normalize column names
        norm.region = row.region_name || row.region || '';
        norm.region_area = row.region_area || 0;
        norm.region_proportion = row.region_proportion || 0;
        norm.gene = row.gene || '';
        norm.x_coordinate = row.global_x !== undefined ? row.global_x : (row.x_coordinate !== undefined ? row.x_coordinate : 0);
        norm.y_coordinate = row.global_y !== undefined ? row.global_y : (row.y_coordinate !== undefined ? row.y_coordinate : 0);
        norm.z_coordinate = row.Z !== undefined ? row.Z : (row.z_coordinate !== undefined ? row.z_coordinate : 0);
        norm.cell_id = row.cell || row.cell_id || '';
        norm.fov = row.fov || '';
        // Check if cell_type exists
        if (row.cell_type !== undefined && row.cell_type !== null && row.cell_type !== '') {
          norm.cell_type = row.cell_type;
          hasCellType = true;
        }
        return norm;
      });
      
      return normalized;
    }

    // Initialize sample selector
    function initializeSampleSelector() {
      const selector = document.getElementById('sampleSelector');
      samples.forEach((sample) => {
        const option = document.createElement('option');
        option.value = sample.path;
        option.textContent = sample.name;
        selector.appendChild(option);
      });
    }

    // Load sample from path (tries to load from relative path)
    function loadSampleFromPath(samplePath) {
      if (!samplePath) {
        return;
      }

      currentFileName = samplePath.split('/').pop();
      rawData = [];
      hasCellType = false;
      document.getElementById('status').textContent = 'Loading sample data...';
      document.getElementById('status').className = 'status loading';
      document.getElementById('loading').style.display = 'block';
      document.getElementById('stats').style.display = 'none';
      document.getElementById('cellTypeFilterGroup').style.display = 'none';

      // Clear existing visualization
      if (canvas && ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      if (axesSvg) {
        axesSvg.selectAll('*').remove();
      }

      // Clear legend
      document.getElementById('legend').style.display = 'none';
      document.getElementById('legendItems').innerHTML = '';
      colorScale = null;
      if (renderTimeout) {
        clearTimeout(renderTimeout);
        renderTimeout = null;
      }
      canvasInteractivitySetup = false; // Reset so it can be set up again

      // Reset filters
      document.getElementById('regionFilter').innerHTML = '<option value="">All Regions</option>';
      document.getElementById('geneFilter').innerHTML = '<option value="">All Genes</option>';
      document.getElementById('cellTypeFilter').innerHTML = '<option value="">All Cell Types</option>';

      // Track parsing progress
      let rowCount = 0;
      let loadFailed = false;

      Papa.parse(samplePath, {
        download: true,
        header: true,
        dynamicTyping: true,
        skipEmptyLines: true,
        step: function(result) {
          if (result.data && Object.keys(result.data).length > 0) {
            rawData.push(result.data);
            rowCount++;
            
            // Update status for large files
            if (rowCount % 50000 === 0) {
              document.getElementById('status').textContent = `Loading sample data... (${rowCount.toLocaleString()} rows loaded)`;
            }
          }
        },
        complete: function(results) {
          console.log('CSV parsing complete. Rows:', rawData.length, 'Errors:', results.errors);
          
          if (rawData.length === 0) {
            // Check if this is a CORS/network error
            const hasNetworkError = results.errors.some(e => 
              e.message && (e.message.includes('NetworkError') || e.message.includes('CORS') || e.message.includes('fetch') || e.message.includes('Failed to fetch'))
            ) || results.errors.length > 0;
            
            if (hasNetworkError && window.location.protocol === 'file:') {
              // Show file input if opened as file:// and we got a network error
              document.getElementById('fileInputGroup').style.display = 'flex';
              document.getElementById('sampleSelectorGroup').style.display = 'none';
              document.getElementById('status').style.display = 'none';
              document.getElementById('loading').style.display = 'none';
              return;
            }
            
            document.getElementById('status').textContent = 'Error: No data loaded from CSV file. The file may be empty or invalid.';
            document.getElementById('status').className = 'status error';
            document.getElementById('loading').style.display = 'none';
            return;
          }

          // Normalize column names
          rawData = normalizeColumns(rawData);
          
          setupVisualization();
          document.getElementById('loading').style.display = 'none';
          document.getElementById('status').textContent = `Loaded ${rawData.length.toLocaleString()} records from ${currentFileName}`;
          document.getElementById('status').className = 'status';
          // Hide status after a moment
          setTimeout(() => {
            document.getElementById('status').style.display = 'none';
          }, 3000);
        },
        error: function(error) {
          console.error('Error loading CSV:', error);
          // Show file input if opened as file://
          if (window.location.protocol === 'file:') {
            document.getElementById('fileInputGroup').style.display = 'flex';
            document.getElementById('sampleSelectorGroup').style.display = 'none';
            document.getElementById('status').style.display = 'none';
          } else {
            document.getElementById('status').textContent = 'Error loading file: ' + (error.message || 'Unknown error');
            document.getElementById('status').className = 'status error';
          }
          document.getElementById('loading').style.display = 'none';
        }
      });
    }

    // Handle file selection (fallback method)
    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) {
        return;
      }

      if (!file.name.endsWith('.csv')) {
        document.getElementById('status').textContent = 'Error: Please select a CSV file.';
        document.getElementById('status').className = 'status error';
        return;
      }

      currentFileName = file.name;
      rawData = [];
      hasCellType = false;
      
      document.getElementById('status').textContent = 'Loading file...';
      document.getElementById('status').className = 'status loading';
      document.getElementById('loading').style.display = 'block';
      document.getElementById('stats').style.display = 'none';
      document.getElementById('cellTypeFilterGroup').style.display = 'none';

      // Clear existing visualization
      if (canvas && ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      if (axesSvg) {
        axesSvg.selectAll('*').remove();
      }

      // Clear legend
      document.getElementById('legend').style.display = 'none';
      document.getElementById('legendItems').innerHTML = '';
      colorScale = null;
      if (renderTimeout) {
        clearTimeout(renderTimeout);
        renderTimeout = null;
      }
      canvasInteractivitySetup = false; // Reset so it can be set up again

      // Reset filters
      document.getElementById('regionFilter').innerHTML = '<option value="">All Regions</option>';
      document.getElementById('geneFilter').innerHTML = '<option value="">All Genes</option>';
      document.getElementById('cellTypeFilter').innerHTML = '<option value="">All Cell Types</option>';

      // Read file using FileReader
      const reader = new FileReader();
      
      reader.onprogress = function(e) {
        if (e.lengthComputable) {
          const percentLoaded = Math.round((e.loaded / e.total) * 100);
          document.getElementById('status').textContent = `Loading file... ${percentLoaded}%`;
        }
      };
      
      reader.onload = function(e) {
        const csvText = e.target.result;
        document.getElementById('status').textContent = 'Parsing CSV data...';
        
        // Track parsing progress
        let rowCount = 0;
        
        Papa.parse(csvText, {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          step: function(result) {
            if (result.data && Object.keys(result.data).length > 0) {
              rawData.push(result.data);
              rowCount++;
              
              // Update status for large files
              if (rowCount % 50000 === 0) {
                document.getElementById('status').textContent = `Parsing CSV... (${rowCount.toLocaleString()} rows parsed)`;
              }
            }
          },
          complete: function(results) {
            console.log('CSV parsing complete. Rows:', rawData.length, 'Errors:', results.errors);
            
            if (results.errors.length > 0) {
              console.warn('Parsing errors:', results.errors);
            }
            
            if (rawData.length === 0) {
              document.getElementById('status').textContent = 'Error: No data loaded from CSV file. The file may be empty or invalid.';
              document.getElementById('status').className = 'status error';
              document.getElementById('loading').style.display = 'none';
              return;
            }

            // Normalize column names
            rawData = normalizeColumns(rawData);
            
            setupVisualization();
            document.getElementById('loading').style.display = 'none';
            document.getElementById('status').textContent = `Loaded ${rawData.length.toLocaleString()} records`;
            document.getElementById('status').className = 'status';
            // Hide status after a moment
            setTimeout(() => {
              if (document.getElementById('status').textContent.includes('Loaded')) {
                document.getElementById('status').style.display = 'none';
              }
            }, 2000);
          },
          error: function(error) {
            console.error('Error parsing CSV:', error);
            document.getElementById('status').textContent = 'Error: Failed to parse CSV file. ' + (error.message || 'Unknown error');
            document.getElementById('status').className = 'status error';
            document.getElementById('loading').style.display = 'none';
          }
        });
      };
      
      reader.onerror = function() {
        document.getElementById('status').textContent = 'Error: Failed to read file.';
        document.getElementById('status').className = 'status error';
        document.getElementById('loading').style.display = 'none';
      };
      
      // Read file as text
      reader.readAsText(file);
    }

    function setupVisualization() {
      // Populate filters
      const regions = [...new Set(rawData.map(d => d.region))].filter(r => r).sort();
      const genes = [...new Set(rawData.map(d => d.gene))].filter(g => g).sort();
      
      // Create color scale for genes using D3's category20 color scheme
      // For more genes, cycle through multiple color schemes
      const colorSchemes = [
        d3.schemeCategory10,
        d3.schemeSet1,
        d3.schemeSet2,
        d3.schemeSet3,
        d3.schemePastel1,
        d3.schemePastel2,
        d3.schemeDark2,
        d3.schemeAccent
      ];
      
      // Flatten all color schemes into one array
      const allColors = colorSchemes.flat();
      
      // Create color scale - assign each gene a unique color
      colorScale = d3.scaleOrdinal()
        .domain(genes)
        .range(allColors);
      
      regions.forEach(region => {
        const option = document.createElement('option');
        option.value = region;
        option.textContent = region;
        document.getElementById('regionFilter').appendChild(option);
      });
      
      genes.forEach(gene => {
        const option = document.createElement('option');
        option.value = gene;
        option.textContent = gene;
        document.getElementById('geneFilter').appendChild(option);
      });

      // Populate cell_type filter if available
      if (hasCellType) {
        const cellTypes = [...new Set(rawData.map(d => d.cell_type))].filter(ct => ct).sort();
        cellTypes.forEach(cellType => {
          const option = document.createElement('option');
          option.value = cellType;
          option.textContent = cellType;
          document.getElementById('cellTypeFilter').appendChild(option);
        });
        document.getElementById('cellTypeFilterGroup').style.display = 'flex';
      }

      // Update stats
      document.getElementById('totalRecords').textContent = rawData.length.toLocaleString();
      document.getElementById('uniqueGenes').textContent = genes.length;
      document.getElementById('uniqueRegions').textContent = regions.length;

      // Show stats
      document.getElementById('stats').style.display = 'flex';
      
      // Setup Canvas and SVG for axes
      const container = document.getElementById('scatterplot').parentElement;
      const width = container.clientWidth;
      const height = 600;
      
      // Setup canvas
      canvas = document.getElementById('scatterplot');
      canvas.width = width;
      canvas.height = height;
      ctx = canvas.getContext('2d');
      
      // Setup SVG for axes (overlaid on canvas)
      axesSvg = d3.select('#axes')
        .attr('width', width)
        .attr('height', height);

      // Setup scales
      const xExtent = d3.extent(rawData, d => d.x_coordinate);
      const yExtent = d3.extent(rawData, d => d.y_coordinate);
      const zExtent = d3.extent(rawData, d => d.z_coordinate);
      
      xScale = d3.scaleLinear()
        .domain(xExtent)
        .range([margin.left, width - margin.right]);

      yScale = d3.scaleLinear()
        .domain(yExtent)
        .range([height - margin.bottom, margin.top]);

      // Update zRange slider
      const zSlider = document.getElementById('zRange');
      zSlider.max = zExtent[1];
      zSlider.value = zExtent[1];
      document.getElementById('zRangeValue').textContent = zExtent[1].toFixed(1);

      // Add axes to SVG
      axesSvg.append('g')
        .attr('class', 'x-axis')
        .attr('transform', `translate(0,${height - margin.bottom})`)
        .call(d3.axisBottom(xScale));

      axesSvg.append('text')
        .attr('class', 'axis-label')
        .attr('x', width / 2)
        .attr('y', height - 10)
        .attr('fill', '#666')
        .style('text-anchor', 'middle')
        .style('font-size', '12px')
        .text('X Coordinate');

      axesSvg.append('g')
        .attr('class', 'y-axis')
        .attr('transform', `translate(${margin.left},0)`)
        .call(d3.axisLeft(yScale));

      axesSvg.append('text')
        .attr('class', 'axis-label')
        .attr('transform', `rotate(-90)`)
        .attr('y', 15)
        .attr('x', -height / 2)
        .attr('fill', '#666')
        .style('text-anchor', 'middle')
        .style('font-size', '12px')
        .text('Y Coordinate');
      
      // Setup canvas mouse events for tooltips
      setupCanvasInteractivity();

      // Update with initial data
      updateVisualization();
      
      // Create legend
      createLegend(genes);
    }

    function createLegend(genes) {
      const legendContainer = document.getElementById('legend');
      const legendItems = document.getElementById('legendItems');
      legendItems.innerHTML = '';
      
      if (!colorScale || genes.length === 0) {
        legendContainer.style.display = 'none';
        return;
      }
      
      // Show legend
      legendContainer.style.display = 'block';
      
      // Create legend items for each gene
      genes.forEach(gene => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.innerHTML = `
          <div class="legend-color" style="background-color: ${colorScale(gene)};"></div>
          <span class="legend-label">${gene}</span>
        `;
        
        // Add click handler to toggle gene visibility
        item.addEventListener('click', function() {
          const isHidden = item.classList.contains('hidden');
          const geneFilter = document.getElementById('geneFilter');
          
          if (isHidden) {
            // Show this gene
            item.classList.remove('hidden');
            // If gene filter is set to this gene or empty, update visualization
            if (!geneFilter.value || geneFilter.value === gene) {
              updateVisualization();
            }
          } else {
            // Hide this gene - filter it out
            item.classList.add('hidden');
            // Temporarily add this gene to a hidden list, or filter it in updateVisualization
            updateVisualization();
          }
        });
        
        legendItems.appendChild(item);
      });
    }

    // Sample data for performance
    function sampleData(data, maxPoints) {
      if (data.length <= maxPoints) {
        return data;
      }
      // Use reservoir sampling for uniform random sampling
      const sampled = data.slice(0, maxPoints);
      for (let i = maxPoints; i < data.length; i++) {
        const j = Math.floor(Math.random() * (i + 1));
        if (j < maxPoints) {
          sampled[j] = data[i];
        }
      }
      return sampled;
    }

    let hoverTimeout = null;
    let lastHoveredPoint = null;
    let canvasInteractivitySetup = false;
    
    function setupCanvasInteractivity() {
      if (!canvas || canvasInteractivitySetup) return;
      canvasInteractivitySetup = true;
      
      canvas.addEventListener('mousemove', function(event) {
        if (!filteredData || filteredData.length === 0 || !xScale || !yScale) return;
        
        // Throttle hover detection for performance
        if (hoverTimeout) {
          clearTimeout(hoverTimeout);
        }
        
        hoverTimeout = setTimeout(() => {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          
          // Find nearest point (within reasonable distance)
          const pointSize = parseFloat(document.getElementById('pointSize').value);
          const searchRadius = pointSize * 4;
          const searchRadiusSq = searchRadius * searchRadius; // Use squared distance to avoid sqrt
          
          let nearestPoint = null;
          let minDistSq = searchRadiusSq;
          
          // Search in rendered data (which may be sampled) - limit search to reasonable number
          const renderedData = window.renderedData || [];
          const maxSearch = Math.min(renderedData.length, 50000); // Limit search for performance
          
          for (let i = 0; i < maxSearch; i++) {
            const d = renderedData[i];
            const px = xScale(d.x_coordinate);
            const py = yScale(d.y_coordinate);
            const dx = x - px;
            const dy = y - py;
            const distSq = dx * dx + dy * dy;
            
            if (distSq < minDistSq) {
              minDistSq = distSq;
              nearestPoint = d;
            }
          }
          
          // Only update if hovered point changed
          if (nearestPoint !== lastHoveredPoint) {
            lastHoveredPoint = nearestPoint;
            hoveredPoint = nearestPoint;
            
            const tooltip = document.getElementById('tooltip');
            if (nearestPoint) {
              let tooltipHtml = `
                <strong>Gene:</strong> ${nearestPoint.gene}<br>
                <strong>Region:</strong> ${nearestPoint.region}<br>
                <strong>Cell ID:</strong> ${nearestPoint.cell_id}<br>
                <strong>Coordinates:</strong> (${nearestPoint.x_coordinate.toFixed(2)}, ${nearestPoint.y_coordinate.toFixed(2)}, ${nearestPoint.z_coordinate.toFixed(2)})
              `;
              if (hasCellType && nearestPoint.cell_type) {
                tooltipHtml += `<br><strong>Cell Type:</strong> ${nearestPoint.cell_type}`;
              }
              tooltip.innerHTML = tooltipHtml;
              tooltip.style.display = 'block';
              tooltip.style.left = (event.pageX + 10) + 'px';
              tooltip.style.top = (event.pageY - 10) + 'px';
              
              // Re-render to show highlight
              renderPoints();
            } else {
              tooltip.style.display = 'none';
              hoveredPoint = null;
              
              // Re-render to remove highlight
              if (lastHoveredPoint) {
                renderPoints();
              }
            }
          } else if (nearestPoint) {
            // Update tooltip position even if point hasn't changed
            const tooltip = document.getElementById('tooltip');
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
          }
        }, 50); // Throttle to ~20 checks per second
      });
      
      canvas.addEventListener('mouseout', function() {
        if (hoverTimeout) {
          clearTimeout(hoverTimeout);
          hoverTimeout = null;
        }
        document.getElementById('tooltip').style.display = 'none';
        hoveredPoint = null;
        lastHoveredPoint = null;
        renderPoints(); // Re-render to remove highlight
      });
    }

    function renderPoints() {
      if (!canvas || !ctx || !filteredData || filteredData.length === 0 || !colorScale || !xScale || !yScale) {
        return;
      }

      const opacity = parseFloat(document.getElementById('opacityRange').value);
      const pointSize = parseFloat(document.getElementById('pointSize').value);

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Sample data if too many points
      const dataToRender = sampleData(filteredData, MAX_POINTS_TO_RENDER);
      window.renderedData = dataToRender; // Store for mouse interaction
      
      // Render points on canvas
      ctx.save();
      ctx.globalAlpha = opacity;
      
      // Group by color for better performance
      const pointsByColor = {};
      dataToRender.forEach(d => {
        const color = colorScale(d.gene);
        if (!pointsByColor[color]) {
          pointsByColor[color] = [];
        }
        pointsByColor[color].push(d);
      });
      
      // Render each color group - use fillRect for small points (faster than arc)
      if (pointSize <= 2) {
        // For small points, use rectangles (much faster)
        Object.keys(pointsByColor).forEach(color => {
          ctx.fillStyle = color;
          pointsByColor[color].forEach(d => {
            const x = xScale(d.x_coordinate) - pointSize;
            const y = yScale(d.y_coordinate) - pointSize;
            ctx.fillRect(x, y, pointSize * 2, pointSize * 2);
          });
        });
      } else {
        // For larger points, use circles
        Object.keys(pointsByColor).forEach(color => {
          ctx.fillStyle = color;
          ctx.beginPath();
          
          pointsByColor[color].forEach(d => {
            const x = xScale(d.x_coordinate);
            const y = yScale(d.y_coordinate);
            ctx.moveTo(x + pointSize, y);
            ctx.arc(x, y, pointSize, 0, Math.PI * 2);
          });
          
          ctx.fill();
        });
      }
      
      // Highlight hovered point if any
      if (hoveredPoint) {
        ctx.globalAlpha = 1;
        ctx.fillStyle = colorScale(hoveredPoint.gene);
        ctx.beginPath();
        const hx = xScale(hoveredPoint.x_coordinate);
        const hy = yScale(hoveredPoint.y_coordinate);
        ctx.arc(hx, hy, pointSize * 2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
    }

    function updateVisualization() {
      if (!rawData || rawData.length === 0 || !colorScale) {
        return;
      }

      const regionFilter = document.getElementById('regionFilter').value;
      const geneFilter = document.getElementById('geneFilter').value;
      const cellTypeFilter = document.getElementById('cellTypeFilter').value;
      const zMax = parseFloat(document.getElementById('zRange').value);
      const opacity = parseFloat(document.getElementById('opacityRange').value);
      const pointSize = parseFloat(document.getElementById('pointSize').value);

      // Get hidden genes from legend
      const hiddenGenes = new Set();
      const legendItems = document.querySelectorAll('.legend-item.hidden');
      legendItems.forEach(item => {
        const label = item.querySelector('.legend-label');
        if (label) {
          hiddenGenes.add(label.textContent.trim());
        }
      });

      // Filter data
      filteredData = rawData.filter(d => {
        const regionMatch = !regionFilter || d.region === regionFilter;
        const geneMatch = !geneFilter || d.gene === geneFilter;
        const cellTypeMatch = !hasCellType || !cellTypeFilter || d.cell_type === cellTypeFilter;
        const zMatch = d.z_coordinate <= zMax;
        const notHidden = !hiddenGenes.has(d.gene);
        return regionMatch && geneMatch && cellTypeMatch && zMatch && notHidden;
      });

      // Update visible points count
      const totalPoints = filteredData.length;
      const pointsToRender = Math.min(totalPoints, MAX_POINTS_TO_RENDER);
      if (pointsToRender < totalPoints) {
        document.getElementById('visiblePoints').textContent = `${pointsToRender.toLocaleString()} of ${totalPoints.toLocaleString()} (sampled)`;
      } else {
        document.getElementById('visiblePoints').textContent = totalPoints.toLocaleString();
      }

      // Debounce rendering for smooth slider interactions
      if (renderTimeout) {
        clearTimeout(renderTimeout);
      }
      
      renderTimeout = setTimeout(() => {
        renderPoints();
        renderTimeout = null;
      }, 16); // ~60fps
    }

    // Initialize on page load
    window.addEventListener('DOMContentLoaded', function() {
      initializeSampleSelector();
      
      // Check if we're on file:// protocol
      if (window.location.protocol === 'file:') {
        // Show file input as the primary method (no sample selector needed)
        document.getElementById('fileInputGroup').style.display = 'flex';
        document.getElementById('sampleSelectorGroup').style.display = 'none';
        document.getElementById('status').style.display = 'none';
      } else {
        // HTTP/HTTPS - automatically load first sample
        if (samples.length > 0) {
          document.getElementById('status').textContent = 'Loading...';
          document.getElementById('status').className = 'status loading';
          
          // Automatically load first sample
          setTimeout(() => {
            document.getElementById('sampleSelector').value = samples[0].path;
            loadSampleFromPath(samples[0].path);
          }, 100);
        } else {
          document.getElementById('status').textContent = 'No samples configured.';
          document.getElementById('status').className = 'status';
        }
      }
    });
  </script>
</body>
</html>
