<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ExSeq Brain AD - Spatial Genomics Data Visualization</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: #f5f5f5;
      color: #333;
      padding: 6px;
      overflow-x: hidden;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      background: white;
      border-radius: 6px;
      padding: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    h1 {
      margin-bottom: 6px;
      color: #2c3e50;
      font-size: 16px;
      font-weight: 600;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 6px;
      margin-bottom: 6px;
      padding: 6px;
      background: #f9f9f9;
      border-radius: 4px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .control-group label {
      font-size: 10px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .control-group select,
    .control-group input[type="text"],
    .control-group input[type="range"] {
      padding: 4px 8px;
      border: 1px solid #ddd;
      border-radius: 3px;
      font-size: 12px;
    }

    .control-group input[type="file"] {
      font-size: 11px;
      cursor: pointer;
      padding: 4px 0;
    }

    .control-group input[type="range"] {
      width: 100%;
    }

    .control-group select {
      min-width: 0;
    }

    .control-group span {
      font-size: 10px;
      color: #666;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 5px;
      margin-bottom: 6px;
    }

    .stat-card {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 6px 8px;
      border-radius: 4px;
      min-width: 0;
    }

    .stat-card h3 {
      font-size: 8px;
      opacity: 0.9;
      margin-bottom: 1px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .stat-card p {
      font-size: 14px;
      font-weight: bold;
      line-height: 1.2;
    }

    .stat-card.secondary {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }

    .stat-card.success {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    }

    .stat-card.warning {
      background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
    }

    #scatterplot {
      width: 100%;
      border: 1px solid #ddd;
      border-radius: 6px;
      background: white;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    .status {
      text-align: left;
      padding: 6px 10px;
      background: #e8f5e9;
      color: #2e7d32;
      border-radius: 3px;
      margin-bottom: 6px;
      font-size: 10px;
      line-height: 1.3;
    }

    .status.error {
      background: #ffebee;
      color: #c62828;
    }

    .status.loading {
      background: #e3f2fd;
      color: #1976d2;
    }

    .status code {
      background: rgba(0, 0, 0, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }

    .status.error code {
      background: rgba(255, 255, 255, 0.3);
    }

    /* Tooltip styling */
    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.9);
      color: white;
      padding: 10px;
      border-radius: 4px;
      pointer-events: none;
      font-size: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      z-index: 1000;
    }

    .axis-label {
      font-size: 10px;
      fill: #666;
    }

    .x-axis text,
    .y-axis text {
      font-size: 10px !important;
      fill: #666;
    }

    .x-axis line,
    .y-axis line,
    .x-axis path,
    .y-axis path {
      stroke: #999;
      stroke-width: 1;
    }

    #legend {
      font-size: 11px;
      position: relative;
      z-index: 10;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
      padding: 3px;
      cursor: pointer;
      border-radius: 4px;
      transition: background-color 0.2s;
    }

    .legend-item:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .legend-color {
      width: 14px;
      height: 14px;
      border-radius: 3px;
      border: 1px solid rgba(0, 0, 0, 0.2);
      flex-shrink: 0;
    }

    .legend-item.hidden .legend-color {
      opacity: 0.3;
    }

    .legend-item.hidden .legend-label {
      text-decoration: line-through;
      opacity: 0.5;
    }

    .legend-label {
      flex: 1;
      user-select: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ExSeq Brain AD - Spatial Genomics Data Visualization</h1>
    
    <div class="status" id="status">Initializing...</div>

    <div class="stats" id="stats" style="display: none;">
      <div class="stat-card">
        <h3>Total Records</h3>
        <p id="totalRecords">-</p>
      </div>
      <div class="stat-card secondary">
        <h3>Unique Genes</h3>
        <p id="uniqueGenes">-</p>
      </div>
      <div class="stat-card success">
        <h3>Unique Regions</h3>
        <p id="uniqueRegions">-</p>
      </div>
      <div class="stat-card warning">
        <h3>Visible Points</h3>
        <p id="visiblePoints">-</p>
      </div>
    </div>

    <div class="controls" id="controls">
      <div class="control-group" id="sampleSelectorGroup">
        <label>Sample</label>
        <select id="sampleSelector" onchange="loadSampleFromPath(this.value)">
          <option value="">Select a sample...</option>
        </select>
      </div>
      <div class="control-group" id="fileInputGroup" style="display: none;">
        <label>Load Data (Fallback)</label>
        <input type="file" id="fileInput" accept=".csv" onchange="handleFileSelect(event)" style="padding: 6px 0; cursor: pointer;">
      </div>
      <div class="control-group">
        <label>Region</label>
        <select id="regionFilter" onchange="updateVisualization()">
          <option value="">All Regions</option>
        </select>
      </div>
      <div class="control-group">
        <label>Gene</label>
        <select id="geneFilter" onchange="updateVisualization()">
          <option value="">All Genes</option>
        </select>
      </div>
      <div class="control-group" id="cellTypeFilterGroup" style="display: none;">
        <label>Cell Type</label>
        <select id="cellTypeFilter" onchange="updateVisualization()">
          <option value="">All Cell Types</option>
        </select>
      </div>
      <div class="control-group">
        <label>Z-Slice Range</label>
        <input type="range" id="zRange" min="0" max="10" step="0.1" value="10" 
               oninput="document.getElementById('zRangeValue').textContent = this.value; updateVisualization();">
        <span>Max: <span id="zRangeValue">10</span></span>
      </div>
      <div class="control-group">
        <label>Opacity</label>
        <input type="range" id="opacityRange" min="0.1" max="1" step="0.1" value="0.5"
               oninput="document.getElementById('opacityValue').textContent = this.value; updateVisualization();">
        <span>Value: <span id="opacityValue">0.5</span></span>
      </div>
      <div class="control-group">
        <label>Point Size</label>
        <input type="range" id="pointSize" min="1" max="10" step="0.5" value="2"
               oninput="document.getElementById('pointSizeValue').textContent = this.value; updateVisualization();">
        <span>Size: <span id="pointSizeValue">2</span></span>
      </div>
    </div>

    <div class="chart-container" style="display: flex; gap: 10px; align-items: flex-start; overflow: hidden; max-width: 100%;">
      <div style="flex: 1; min-width: 0; position: relative;">
        <canvas id="scatterplot" style="display: block; border: 1px solid #ddd; border-radius: 4px;"></canvas>
        <svg id="axes" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 1;"></svg>
      </div>
      <div id="legend" style="min-width: 180px; max-width: 220px; overflow-y: auto; overflow-x: hidden; padding: 10px; background: #f9f9f9; border-radius: 6px; border: 1px solid #ddd; display: none; flex-shrink: 0; align-self: stretch;">
        <h3 style="margin: 0 0 8px 0; font-size: 12px; font-weight: 600; color: #333;">Gene Colors</h3>
        <div id="legendItems"></div>
      </div>
    </div>
    <div class="loading" id="loading" style="display: none;">Loading data...</div>
  </div>

  <div class="tooltip" id="tooltip" style="display: none;"></div>

  <script>
    // Sample configuration - loaded dynamically from manifest.json
    let samples = [];

    let rawData = [];
    let filteredData = [];
    let canvas, ctx, axesSvg, xScale, yScale;
    let hasCellType = false;
    let colorScale = null;
    const margin = { top: 30, right: 30, bottom: 45, left: 45 };
    let currentFileName = null;
    const MAX_POINTS_TO_RENDER = 100000; // Maximum points to render for performance
    let renderTimeout = null;
    let hoveredPoint = null;

    // Column name normalization function
    function normalizeColumns(data) {
      // Reset cell type flag before checking
      hasCellType = false;
      
      const normalized = data.map(row => {
        const norm = {};
        // Normalize column names
        norm.region = row.region_name || row.region || '';
        norm.region_area = row.region_area || 0;
        norm.region_proportion = row.region_proportion || 0;
        norm.gene = row.gene || '';
        norm.x_coordinate = row.global_x !== undefined ? row.global_x : (row.x_coordinate !== undefined ? row.x_coordinate : 0);
        norm.y_coordinate = row.global_y !== undefined ? row.global_y : (row.y_coordinate !== undefined ? row.y_coordinate : 0);
        norm.z_coordinate = row.Z !== undefined ? row.Z : (row.z_coordinate !== undefined ? row.z_coordinate : 0);
        norm.cell_id = row.cell || row.cell_id || '';
        norm.fov = row.fov || '';
        // Check if cell_type exists
        if (row.cell_type !== undefined && row.cell_type !== null && row.cell_type !== '') {
          norm.cell_type = row.cell_type;
          hasCellType = true;
        }
        return norm;
      });
      
      return normalized;
    }

    // Load manifest.json to get list of available CSV files
    async function loadManifest() {
      try {
        const manifestPath = 'data/csvs/manifest.json';
        const response = await fetch(manifestPath);
        
        if (!response.ok) {
          throw new Error(`Failed to load manifest: ${response.status} ${response.statusText}`);
        }
        
        const manifest = await response.json();
        samples = manifest;
        
        console.log(`Loaded manifest with ${samples.length} CSV files`);
        return true;
      } catch (error) {
        console.error('Error loading manifest:', error);
        samples = []; // Empty array on error
        return false;
      }
    }

    // Initialize sample selector
    function initializeSampleSelector() {
      const selector = document.getElementById('sampleSelector');
      // Clear existing options except the first one
      while (selector.children.length > 1) {
        selector.removeChild(selector.lastChild);
      }
      
      if (samples.length === 0) {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'No samples available';
        selector.appendChild(option);
        return;
      }
      
      samples.forEach((sample) => {
        const option = document.createElement('option');
        option.value = sample.path;
        option.textContent = sample.name;
        selector.appendChild(option);
      });
    }

    // Load sample from path (tries to load from relative path)
    function loadSampleFromPath(samplePath) {
      if (!samplePath) {
        return;
      }

      currentFileName = samplePath.split('/').pop();
      rawData = [];
      hasCellType = false;
      document.getElementById('status').textContent = 'Loading sample data...';
      document.getElementById('status').className = 'status loading';
      document.getElementById('loading').style.display = 'block';
      document.getElementById('stats').style.display = 'none';
      document.getElementById('cellTypeFilterGroup').style.display = 'none';

      // Clear existing visualization
      if (canvas && ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      if (axesSvg) {
        axesSvg.selectAll('*').remove();
      }

      // Clear legend
      document.getElementById('legend').style.display = 'none';
      document.getElementById('legendItems').innerHTML = '';
      colorScale = null;
      if (renderTimeout) {
        clearTimeout(renderTimeout);
        renderTimeout = null;
      }
      canvasInteractivitySetup = false; // Reset so it can be set up again

      // Reset filters
      document.getElementById('regionFilter').innerHTML = '<option value="">All Regions</option>';
      document.getElementById('geneFilter').innerHTML = '<option value="">All Genes</option>';
      document.getElementById('cellTypeFilter').innerHTML = '<option value="">All Cell Types</option>';

      // Track parsing progress
      let rowCount = 0;
      
      // Pre-extract unique values during parsing for faster filter setup
      const regionsSet = new Set();
      const genesSet = new Set();
      const cellTypesSet = new Set();

      Papa.parse(samplePath, {
        download: true,
        header: true,
        dynamicTyping: true,
        skipEmptyLines: true,
        // Note: worker disabled due to URL issues with CDN version
        step: function(result) {
          if (result.data && Object.keys(result.data).length > 0) {
            // Normalize during parsing to avoid second pass
            const norm = {};
            norm.region = result.data.region_name || result.data.region || '';
            norm.gene = result.data.gene || '';
            norm.x_coordinate = result.data.global_x !== undefined ? result.data.global_x : (result.data.x_coordinate !== undefined ? result.data.x_coordinate : 0);
            norm.y_coordinate = result.data.global_y !== undefined ? result.data.global_y : (result.data.y_coordinate !== undefined ? result.data.y_coordinate : 0);
            norm.z_coordinate = result.data.Z !== undefined ? result.data.Z : (result.data.z_coordinate !== undefined ? result.data.z_coordinate : 0);
            norm.cell_id = result.data.cell || result.data.cell_id || '';
            norm.fov = result.data.fov || '';
            norm.region_area = result.data.region_area || 0;
            norm.region_proportion = result.data.region_proportion || 0;
            
            // Check cell_type
            if (result.data.cell_type !== undefined && result.data.cell_type !== null && result.data.cell_type !== '') {
              norm.cell_type = result.data.cell_type;
              hasCellType = true;
              cellTypesSet.add(result.data.cell_type);
            }
            
            // Extract unique values during parsing
            if (norm.region) regionsSet.add(norm.region);
            if (norm.gene) genesSet.add(norm.gene);
            
            rawData.push(norm);
            rowCount++;
            
            // Update status for large files (less frequently for better performance)
            if (rowCount % 100000 === 0) {
              requestAnimationFrame(() => {
                document.getElementById('status').textContent = `Loading sample data... (${rowCount.toLocaleString()} rows loaded)`;
              });
            }
          }
        },
        complete: function(results) {
          console.log('CSV parsing complete. Rows:', rawData.length, 'Errors:', results.errors);
          
          if (rawData.length === 0) {
            // Check if this is a CORS/network error
            const hasNetworkError = results.errors.some(e => 
              e.message && (e.message.includes('NetworkError') || e.message.includes('CORS') || e.message.includes('fetch') || e.message.includes('Failed to fetch'))
            ) || results.errors.length > 0;
            
            if (hasNetworkError && window.location.protocol === 'file:') {
              // Show file input if opened as file:// and we got a network error
              document.getElementById('fileInputGroup').style.display = 'flex';
              document.getElementById('sampleSelectorGroup').style.display = 'none';
              document.getElementById('status').style.display = 'none';
              document.getElementById('loading').style.display = 'none';
              return;
            }
            
            document.getElementById('status').textContent = 'Error: No data loaded from CSV file. The file may be empty or invalid.';
            document.getElementById('status').className = 'status error';
            document.getElementById('loading').style.display = 'none';
            return;
          }

          // Setup visualization with pre-extracted unique values
          setupVisualizationFast(Array.from(regionsSet), Array.from(genesSet), Array.from(cellTypesSet));
          document.getElementById('loading').style.display = 'none';
          document.getElementById('status').textContent = `Loaded ${rawData.length.toLocaleString()} records from ${currentFileName}`;
          document.getElementById('status').className = 'status';
          // Hide status after a moment
          setTimeout(() => {
            document.getElementById('status').style.display = 'none';
          }, 3000);
        },
        error: function(error) {
          console.error('Error loading CSV:', error);
          // Show file input if opened as file://
          if (window.location.protocol === 'file:') {
            document.getElementById('fileInputGroup').style.display = 'flex';
            document.getElementById('sampleSelectorGroup').style.display = 'none';
            document.getElementById('status').style.display = 'none';
          } else {
            document.getElementById('status').textContent = 'Error loading file: ' + (error.message || 'Unknown error');
            document.getElementById('status').className = 'status error';
          }
          document.getElementById('loading').style.display = 'none';
        }
      });
    }

    // Handle file selection (fallback method)
    function handleFileSelect(event) {
      const file = event.target.files[0];
      if (!file) {
        return;
      }

      if (!file.name.endsWith('.csv')) {
        document.getElementById('status').textContent = 'Error: Please select a CSV file.';
        document.getElementById('status').className = 'status error';
        return;
      }

      currentFileName = file.name;
      rawData = [];
      hasCellType = false;
      
      document.getElementById('status').textContent = 'Loading file...';
      document.getElementById('status').className = 'status loading';
      document.getElementById('loading').style.display = 'block';
      document.getElementById('stats').style.display = 'none';
      document.getElementById('cellTypeFilterGroup').style.display = 'none';

      // Clear existing visualization
      if (canvas && ctx) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      if (axesSvg) {
        axesSvg.selectAll('*').remove();
      }

      // Clear legend
      document.getElementById('legend').style.display = 'none';
      document.getElementById('legendItems').innerHTML = '';
      colorScale = null;
      if (renderTimeout) {
        clearTimeout(renderTimeout);
        renderTimeout = null;
      }
      canvasInteractivitySetup = false; // Reset so it can be set up again

      // Reset filters
      document.getElementById('regionFilter').innerHTML = '<option value="">All Regions</option>';
      document.getElementById('geneFilter').innerHTML = '<option value="">All Genes</option>';
      document.getElementById('cellTypeFilter').innerHTML = '<option value="">All Cell Types</option>';

      // Read file using FileReader
      const reader = new FileReader();
      
      reader.onprogress = function(e) {
        if (e.lengthComputable) {
          const percentLoaded = Math.round((e.loaded / e.total) * 100);
          document.getElementById('status').textContent = `Loading file... ${percentLoaded}%`;
        }
      };
      
      reader.onload = function(e) {
        const csvText = e.target.result;
        document.getElementById('status').textContent = 'Parsing CSV data...';
        
        // Track parsing progress
        let rowCount = 0;
        
        // Pre-extract unique values during parsing
        const regionsSet = new Set();
        const genesSet = new Set();
        const cellTypesSet = new Set();
        
        Papa.parse(csvText, {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          // Note: worker disabled due to URL issues with CDN version
          step: function(result) {
            if (result.data && Object.keys(result.data).length > 0) {
              // Normalize during parsing
              const norm = {};
              norm.region = result.data.region_name || result.data.region || '';
              norm.gene = result.data.gene || '';
              norm.x_coordinate = result.data.global_x !== undefined ? result.data.global_x : (result.data.x_coordinate !== undefined ? result.data.x_coordinate : 0);
              norm.y_coordinate = result.data.global_y !== undefined ? result.data.global_y : (result.data.y_coordinate !== undefined ? result.data.y_coordinate : 0);
              norm.z_coordinate = result.data.Z !== undefined ? result.data.Z : (result.data.z_coordinate !== undefined ? result.data.z_coordinate : 0);
              norm.cell_id = result.data.cell || result.data.cell_id || '';
              norm.fov = result.data.fov || '';
              norm.region_area = result.data.region_area || 0;
              norm.region_proportion = result.data.region_proportion || 0;
              
              if (result.data.cell_type !== undefined && result.data.cell_type !== null && result.data.cell_type !== '') {
                norm.cell_type = result.data.cell_type;
                hasCellType = true;
                cellTypesSet.add(result.data.cell_type);
              }
              
              if (norm.region) regionsSet.add(norm.region);
              if (norm.gene) genesSet.add(norm.gene);
              
              rawData.push(norm);
              rowCount++;
              
              // Update status less frequently
              if (rowCount % 100000 === 0) {
                requestAnimationFrame(() => {
                  document.getElementById('status').textContent = `Parsing CSV... (${rowCount.toLocaleString()} rows parsed)`;
                });
              }
            }
          },
          complete: function(results) {
            console.log('CSV parsing complete. Rows:', rawData.length, 'Errors:', results.errors);
            
            if (results.errors.length > 0) {
              console.warn('Parsing errors:', results.errors);
            }
            
            if (rawData.length === 0) {
              document.getElementById('status').textContent = 'Error: No data loaded from CSV file. The file may be empty or invalid.';
              document.getElementById('status').className = 'status error';
              document.getElementById('loading').style.display = 'none';
              return;
            }

            // Setup visualization with pre-extracted values
            setupVisualizationFast(Array.from(regionsSet), Array.from(genesSet), Array.from(cellTypesSet));
            document.getElementById('loading').style.display = 'none';
            document.getElementById('status').textContent = `Loaded ${rawData.length.toLocaleString()} records`;
            document.getElementById('status').className = 'status';
            // Hide status after a moment
            setTimeout(() => {
              if (document.getElementById('status').textContent.includes('Loaded')) {
                document.getElementById('status').style.display = 'none';
              }
            }, 2000);
          },
          error: function(error) {
            console.error('Error parsing CSV:', error);
            document.getElementById('status').textContent = 'Error: Failed to parse CSV file. ' + (error.message || 'Unknown error');
            document.getElementById('status').className = 'status error';
            document.getElementById('loading').style.display = 'none';
          }
        });
      };
      
      reader.onerror = function() {
        document.getElementById('status').textContent = 'Error: Failed to read file.';
        document.getElementById('status').className = 'status error';
        document.getElementById('loading').style.display = 'none';
      };
      
      // Read file as text
      reader.readAsText(file);
    }

    // Fast version that uses pre-extracted unique values
    function setupVisualizationFast(regions, genes, cellTypes) {
      // Sort the pre-extracted arrays
      regions = regions.filter(r => r).sort();
      genes = genes.filter(g => g).sort();
      cellTypes = cellTypes.filter(ct => ct).sort();
      
      setupVisualizationWithValues(regions, genes, cellTypes);
    }
    
    // Original version for backward compatibility
    function setupVisualization() {
      // Populate filters
      const regions = [...new Set(rawData.map(d => d.region))].filter(r => r).sort();
      const genes = [...new Set(rawData.map(d => d.gene))].filter(g => g).sort();
      
      // Populate cell_type filter if available
      let cellTypes = [];
      if (hasCellType) {
        cellTypes = [...new Set(rawData.map(d => d.cell_type))].filter(ct => ct).sort();
      }
      
      setupVisualizationWithValues(regions, genes, cellTypes);
    }
    
    function setupVisualizationWithValues(regions, genes, cellTypes) {
      
      // Create color scale for genes using D3's category20 color scheme
      // For more genes, cycle through multiple color schemes
      const colorSchemes = [
        d3.schemeCategory10,
        d3.schemeSet1,
        d3.schemeSet2,
        d3.schemeSet3,
        d3.schemePastel1,
        d3.schemePastel2,
        d3.schemeDark2,
        d3.schemeAccent
      ];
      
      // Flatten all color schemes into one array
      const allColors = colorSchemes.flat();
      
      // Create color scale - assign each gene a unique color
      colorScale = d3.scaleOrdinal()
        .domain(genes)
        .range(allColors);
      
      // Batch DOM updates using DocumentFragment for better performance
      const regionFragment = document.createDocumentFragment();
      regions.forEach(region => {
        const option = document.createElement('option');
        option.value = region;
        option.textContent = region;
        regionFragment.appendChild(option);
      });
      document.getElementById('regionFilter').appendChild(regionFragment);
      
      const geneFragment = document.createDocumentFragment();
      genes.forEach(gene => {
        const option = document.createElement('option');
        option.value = gene;
        option.textContent = gene;
        geneFragment.appendChild(option);
      });
      document.getElementById('geneFilter').appendChild(geneFragment);

      // Populate cell_type filter if available
      if (hasCellType && cellTypes.length > 0) {
        const cellTypeFragment = document.createDocumentFragment();
        cellTypes.forEach(cellType => {
          const option = document.createElement('option');
          option.value = cellType;
          option.textContent = cellType;
          cellTypeFragment.appendChild(option);
        });
        document.getElementById('cellTypeFilter').appendChild(cellTypeFragment);
        document.getElementById('cellTypeFilterGroup').style.display = 'flex';
      }

      // Update stats
      document.getElementById('totalRecords').textContent = rawData.length.toLocaleString();
      document.getElementById('uniqueGenes').textContent = genes.length;
      document.getElementById('uniqueRegions').textContent = regions.length;

      // Show stats
      document.getElementById('stats').style.display = 'flex';
      
      // Setup Canvas and SVG for axes
      const container = document.getElementById('scatterplot').parentElement;
      // Use getBoundingClientRect to get accurate rendered width
      const containerRect = container.getBoundingClientRect();
      const width = containerRect.width || container.clientWidth;
      const height = 400;
      
      // Setup canvas - set both internal resolution and CSS size to match
      canvas = document.getElementById('scatterplot');
      canvas.width = width;
      canvas.height = height;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx = canvas.getContext('2d');
      
      // Update legend height to match canvas
      setTimeout(() => updateLegendHeight(), 0);
      
      // Clear any existing axes before creating new ones
      if (axesSvg) {
        axesSvg.selectAll('*').remove();
      }
      
      // Setup SVG for axes (overlaid on canvas) - must match canvas exactly
      axesSvg = d3.select('#axes')
        .attr('width', width)
        .attr('height', height)
        .style('width', width + 'px')
        .style('height', height + 'px');

      // Setup scales
      const xExtent = d3.extent(rawData, d => d.x_coordinate);
      const yExtent = d3.extent(rawData, d => d.y_coordinate);
      const zExtent = d3.extent(rawData, d => d.z_coordinate);
      
      xScale = d3.scaleLinear()
        .domain(xExtent)
        .range([margin.left, width - margin.right]);

      yScale = d3.scaleLinear()
        .domain(yExtent)
        .range([height - margin.bottom, margin.top]);

      // Update zRange slider
      const zSlider = document.getElementById('zRange');
      zSlider.max = zExtent[1];
      zSlider.value = zExtent[1];
      document.getElementById('zRangeValue').textContent = zExtent[1].toFixed(1);

      // Add axes to SVG
      axesSvg.append('g')
        .attr('class', 'x-axis')
        .attr('transform', `translate(0,${height - margin.bottom})`)
        .call(d3.axisBottom(xScale))
        .selectAll('text')
        .style('font-size', '10px');

      axesSvg.append('text')
        .attr('class', 'axis-label')
        .attr('x', width / 2)
        .attr('y', height - 10)
        .attr('fill', '#666')
        .style('text-anchor', 'middle')
        .style('font-size', '10px')
        .text('X Coordinate');

      axesSvg.append('g')
        .attr('class', 'y-axis')
        .attr('transform', `translate(${margin.left},0)`)
        .call(d3.axisLeft(yScale))
        .selectAll('text')
        .style('font-size', '10px');

      axesSvg.append('text')
        .attr('class', 'axis-label')
        .attr('transform', `rotate(-90)`)
        .attr('y', 15)
        .attr('x', -height / 2)
        .attr('fill', '#666')
        .style('text-anchor', 'middle')
        .style('font-size', '10px')
        .text('Y Coordinate');
      
      // Setup canvas mouse events for tooltips
      setupCanvasInteractivity();

      // Update with initial data
      updateVisualization();
      
      // Create legend and set dynamic height
      createLegend(genes);
      updateLegendHeight();
    }

    function updateLegendHeight() {
      const legend = document.getElementById('legend');
      const canvas = document.getElementById('scatterplot');
      if (legend && canvas && canvas.style.height) {
        // Match legend height to canvas height dynamically
        const canvasHeight = canvas.height || parseInt(canvas.style.height) || 400;
        legend.style.height = canvasHeight + 'px';
        legend.style.maxHeight = canvasHeight + 'px';
      }
    }

    function createLegend(genes) {
      const legendContainer = document.getElementById('legend');
      const legendItems = document.getElementById('legendItems');
      legendItems.innerHTML = '';
      
      if (!colorScale || genes.length === 0) {
        legendContainer.style.display = 'none';
        return;
      }
      
      // Show legend
      legendContainer.style.display = 'block';
      
      // Update height dynamically
      updateLegendHeight();
      
      // Create legend items for each gene
      genes.forEach(gene => {
        const item = document.createElement('div');
        item.className = 'legend-item';
        item.innerHTML = `
          <div class="legend-color" style="background-color: ${colorScale(gene)};"></div>
          <span class="legend-label">${gene}</span>
        `;
        
        // Add click handler to toggle gene visibility
        item.addEventListener('click', function() {
          const isHidden = item.classList.contains('hidden');
          const geneFilter = document.getElementById('geneFilter');
          
          if (isHidden) {
            // Show this gene
            item.classList.remove('hidden');
            // If gene filter is set to this gene or empty, update visualization
            if (!geneFilter.value || geneFilter.value === gene) {
              updateVisualization();
            }
          } else {
            // Hide this gene - filter it out
            item.classList.add('hidden');
            // Temporarily add this gene to a hidden list, or filter it in updateVisualization
            updateVisualization();
          }
        });
        
        legendItems.appendChild(item);
      });
    }

    // Sample data for performance
    function sampleData(data, maxPoints) {
      if (data.length <= maxPoints) {
        return data;
      }
      // Use reservoir sampling for uniform random sampling
      const sampled = data.slice(0, maxPoints);
      for (let i = maxPoints; i < data.length; i++) {
        const j = Math.floor(Math.random() * (i + 1));
        if (j < maxPoints) {
          sampled[j] = data[i];
        }
      }
      return sampled;
    }

    let hoverTimeout = null;
    let lastHoveredPoint = null;
    let canvasInteractivitySetup = false;
    
    function setupCanvasInteractivity() {
      if (!canvas || canvasInteractivitySetup) return;
      canvasInteractivitySetup = true;
      
      canvas.addEventListener('mousemove', function(event) {
        if (!filteredData || filteredData.length === 0 || !xScale || !yScale) return;
        
        // Throttle hover detection for performance
        if (hoverTimeout) {
          clearTimeout(hoverTimeout);
        }
        
        hoverTimeout = setTimeout(() => {
          const rect = canvas.getBoundingClientRect();
          const x = event.clientX - rect.left;
          const y = event.clientY - rect.top;
          
          // Find nearest point (within reasonable distance)
          const pointSize = parseFloat(document.getElementById('pointSize').value);
          const searchRadius = pointSize * 4;
          const searchRadiusSq = searchRadius * searchRadius; // Use squared distance to avoid sqrt
          
          let nearestPoint = null;
          let minDistSq = searchRadiusSq;
          
          // Search in rendered data (which may be sampled) - limit search to reasonable number
          const renderedData = window.renderedData || [];
          const maxSearch = Math.min(renderedData.length, 50000); // Limit search for performance
          
          for (let i = 0; i < maxSearch; i++) {
            const d = renderedData[i];
            const px = xScale(d.x_coordinate);
            const py = yScale(d.y_coordinate);
            const dx = x - px;
            const dy = y - py;
            const distSq = dx * dx + dy * dy;
            
            if (distSq < minDistSq) {
              minDistSq = distSq;
              nearestPoint = d;
            }
          }
          
          // Only update if hovered point changed
          if (nearestPoint !== lastHoveredPoint) {
            lastHoveredPoint = nearestPoint;
            hoveredPoint = nearestPoint;
            
            const tooltip = document.getElementById('tooltip');
            if (nearestPoint) {
              let tooltipHtml = `
                <strong>Gene:</strong> ${nearestPoint.gene}<br>
                <strong>Region:</strong> ${nearestPoint.region}<br>
                <strong>Cell ID:</strong> ${nearestPoint.cell_id}<br>
                <strong>Coordinates:</strong> (${nearestPoint.x_coordinate.toFixed(2)}, ${nearestPoint.y_coordinate.toFixed(2)}, ${nearestPoint.z_coordinate.toFixed(2)})
              `;
              if (hasCellType && nearestPoint.cell_type) {
                tooltipHtml += `<br><strong>Cell Type:</strong> ${nearestPoint.cell_type}`;
              }
              tooltip.innerHTML = tooltipHtml;
              tooltip.style.display = 'block';
              tooltip.style.left = (event.pageX + 10) + 'px';
              tooltip.style.top = (event.pageY - 10) + 'px';
              
              // Re-render to show highlight
              renderPoints();
            } else {
              tooltip.style.display = 'none';
              hoveredPoint = null;
              
              // Re-render to remove highlight
              if (lastHoveredPoint) {
                renderPoints();
              }
            }
          } else if (nearestPoint) {
            // Update tooltip position even if point hasn't changed
            const tooltip = document.getElementById('tooltip');
            tooltip.style.left = (event.pageX + 10) + 'px';
            tooltip.style.top = (event.pageY - 10) + 'px';
          }
        }, 50); // Throttle to ~20 checks per second
      });
      
      canvas.addEventListener('mouseout', function() {
        if (hoverTimeout) {
          clearTimeout(hoverTimeout);
          hoverTimeout = null;
        }
        document.getElementById('tooltip').style.display = 'none';
        hoveredPoint = null;
        lastHoveredPoint = null;
        renderPoints(); // Re-render to remove highlight
      });
    }

    function renderPoints() {
      if (!canvas || !ctx || !filteredData || filteredData.length === 0 || !colorScale || !xScale || !yScale) {
        return;
      }

      const opacity = parseFloat(document.getElementById('opacityRange').value);
      const pointSize = parseFloat(document.getElementById('pointSize').value);

      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Sample data if too many points
      const dataToRender = sampleData(filteredData, MAX_POINTS_TO_RENDER);
      window.renderedData = dataToRender; // Store for mouse interaction
      
      // Render points on canvas
      ctx.save();
      ctx.globalAlpha = opacity;
      
      // Group by color for better performance
      const pointsByColor = {};
      dataToRender.forEach(d => {
        const color = colorScale(d.gene);
        if (!pointsByColor[color]) {
          pointsByColor[color] = [];
        }
        pointsByColor[color].push(d);
      });
      
      // Render each color group - use fillRect for small points (faster than arc)
      if (pointSize <= 2) {
        // For small points, use rectangles (much faster)
        Object.keys(pointsByColor).forEach(color => {
          ctx.fillStyle = color;
          pointsByColor[color].forEach(d => {
            const x = xScale(d.x_coordinate) - pointSize;
            const y = yScale(d.y_coordinate) - pointSize;
            ctx.fillRect(x, y, pointSize * 2, pointSize * 2);
          });
        });
      } else {
        // For larger points, use circles
        Object.keys(pointsByColor).forEach(color => {
          ctx.fillStyle = color;
          ctx.beginPath();
          
          pointsByColor[color].forEach(d => {
            const x = xScale(d.x_coordinate);
            const y = yScale(d.y_coordinate);
            ctx.moveTo(x + pointSize, y);
            ctx.arc(x, y, pointSize, 0, Math.PI * 2);
          });
          
          ctx.fill();
        });
      }
      
      // Highlight hovered point if any
      if (hoveredPoint) {
        ctx.globalAlpha = 1;
        ctx.fillStyle = colorScale(hoveredPoint.gene);
        ctx.beginPath();
        const hx = xScale(hoveredPoint.x_coordinate);
        const hy = yScale(hoveredPoint.y_coordinate);
        ctx.arc(hx, hy, pointSize * 2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
    }

    function updateVisualization() {
      if (!rawData || rawData.length === 0 || !colorScale) {
        return;
      }

      const regionFilter = document.getElementById('regionFilter').value;
      const geneFilter = document.getElementById('geneFilter').value;
      const cellTypeFilter = document.getElementById('cellTypeFilter').value;
      const zMax = parseFloat(document.getElementById('zRange').value);
      const opacity = parseFloat(document.getElementById('opacityRange').value);
      const pointSize = parseFloat(document.getElementById('pointSize').value);

      // Get hidden genes from legend
      const hiddenGenes = new Set();
      const legendItems = document.querySelectorAll('.legend-item.hidden');
      legendItems.forEach(item => {
        const label = item.querySelector('.legend-label');
        if (label) {
          hiddenGenes.add(label.textContent.trim());
        }
      });

      // Filter data
      filteredData = rawData.filter(d => {
        const regionMatch = !regionFilter || d.region === regionFilter;
        const geneMatch = !geneFilter || d.gene === geneFilter;
        const cellTypeMatch = !hasCellType || !cellTypeFilter || d.cell_type === cellTypeFilter;
        const zMatch = d.z_coordinate <= zMax;
        const notHidden = !hiddenGenes.has(d.gene);
        return regionMatch && geneMatch && cellTypeMatch && zMatch && notHidden;
      });

      // Update visible points count
      const totalPoints = filteredData.length;
      const pointsToRender = Math.min(totalPoints, MAX_POINTS_TO_RENDER);
      if (pointsToRender < totalPoints) {
        document.getElementById('visiblePoints').textContent = `${pointsToRender.toLocaleString()} of ${totalPoints.toLocaleString()} (sampled)`;
      } else {
        document.getElementById('visiblePoints').textContent = totalPoints.toLocaleString();
      }

      // Debounce rendering for smooth slider interactions
      if (renderTimeout) {
        clearTimeout(renderTimeout);
      }
      
      renderTimeout = setTimeout(() => {
        renderPoints();
        renderTimeout = null;
      }, 16); // ~60fps
    }

    // Initialize on page load
    window.addEventListener('DOMContentLoaded', async function() {
      // Check if we're on file:// protocol
      if (window.location.protocol === 'file:') {
        // Show file input as the primary method (no sample selector needed)
        document.getElementById('fileInputGroup').style.display = 'flex';
        document.getElementById('sampleSelectorGroup').style.display = 'none';
        document.getElementById('status').style.display = 'none';
        return;
      }
      
      // HTTP/HTTPS - load manifest and initialize
      document.getElementById('status').textContent = 'Loading sample list...';
      document.getElementById('status').className = 'status loading';
      
      const manifestLoaded = await loadManifest();
      
      if (!manifestLoaded) {
        // Manifest failed to load - show error and fallback to file input
        document.getElementById('status').textContent = 'Error: Could not load sample list. Please use the file upload option below.';
        document.getElementById('status').className = 'status error';
        document.getElementById('fileInputGroup').style.display = 'flex';
        document.getElementById('sampleSelectorGroup').style.display = 'none';
        return;
      }
      
      // Initialize sample selector with loaded manifest
      initializeSampleSelector();
      
      // Automatically load first sample if available
      if (samples.length > 0) {
        document.getElementById('status').textContent = 'Loading...';
        document.getElementById('status').className = 'status loading';
        
        // Automatically load first sample
        setTimeout(() => {
          document.getElementById('sampleSelector').value = samples[0].path;
          loadSampleFromPath(samples[0].path);
        }, 100);
      } else {
        document.getElementById('status').textContent = 'No samples available. Please use the file upload option.';
        document.getElementById('status').className = 'status error';
        document.getElementById('fileInputGroup').style.display = 'flex';
      }
    });

    // Update legend height on window resize
    let resizeTimeout = null;
    window.addEventListener('resize', function() {
      if (resizeTimeout) {
        clearTimeout(resizeTimeout);
      }
      resizeTimeout = setTimeout(() => {
        updateLegendHeight();
      }, 100);
    });
  </script>
</body>
</html>
